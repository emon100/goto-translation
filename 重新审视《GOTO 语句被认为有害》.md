# 重新审视《GOTO 语句被认为有害》：第一部分

## 译者前言

Dijkstra的《GOTO 语句被认为有害》一文我好奇很久了，因为一直只知文章其名但从未未闻其声，在国内也很难搜到相关信息。这次看到05年写的[这篇](http://david.tribble.com/text/goto.html)对《GOTO 语句被认为有害》带批注和评论goto的用法的文章，我大喜，于是打算乘着假期把这文章阅读并翻译了，同时也把这文章分享给大家。限于译者水平，可能翻译的不太通顺，还请大家多多指教。以下是文章的第一部分：对《GOTO 语句被认为有害》的介绍，对历史背景的描述以及正文和评注。

## 介绍

这是对**Edsger W. Dijkstra**于1968年致*计算机科学协会通讯*（CACM）的信件的讨论和分析，他在信中呼吁废除编程语言中的 **goto** 语句。

自首次发表以来，这封信已经名闻遐迩（或声名狼藉，取决于您对goto语句的感受），并且可能是有关编程被引用最多的文档。但它可能也是编程史上被阅读最少的文档。

大多数程序员都听过*“永不使用goto语句”*的格言，但在今天，很少有计算机科学专业的学生从Dijkstra反对goto的历史背景中受益。现代编程的教条已经接受了“goto语句是邪恶的”的神话，但有启发性的是阅读原始文本并意识到这种教条的信念完全没抓住重点。

写那封信，时使用 goto 语句手动编写<b>迭代循环</b>，<b>if-then</b>和其他控制结构是被人们接受的编程方式，大多数编程语言对我们今天认为理所当然的基本控制流语句都不支持或者仅提供了非常有限的形式。Dijkstra并不是想说 goto 的<b>所有</b>用途都不好，而是应该存在高级控制结构，且正确使用它们将消除当时流行的 goto 的<b>大多数</b>用途。Dijkstra仍然允许将goto用于更复杂的编程控制结构。



## 背景

Dijkstra和其他人（C. A. R. Hoare，Niklaus Wirth等人）在早期为新兴的计算机编程学科提供的工作的重要性不可低估。他们对于建立计算机科学这门严谨的学科以及将算法编程作为数学和逻辑学的官方分支有极有指导意义的贡献。

计算机科学形成初期，Dijkstra就像他的大多数同事一样，是一位接受过大量数学培训的学者。毫不意外，许多早期的计算机工程工作都是为了让计算机编程成为一门具有扎实数学与逻辑基础的、严谨的工程学科。它们的愿景是开发出一门编程语言，用这门编程语言写出的程序的正确性可以被证明。这种称为*形式验证*的理论是一小套编程结构（如**if-then-else** ，循环语句，原始数据类型等)可以被设计出且强大到能定义任何可能的编程任务，并且可以在数学上证明是正确的（即没有逻辑错误）。

这项运动始于1950年代后期，其精神类似于早期大卫·希尔伯特（David Hilbert）所说的*希尔伯特纲领*（*Hilbert's programme*)的数学运动。这个数学运动旨在将所有数学用自然数的组成部分以及简单的逻辑和算术规则编纂为一套完整的，包罗万象的法则。Alas，库尔特·哥德尔的不完全性定理使这个梦想破灭，证明有存在于逻辑可证明性领域之外的数学真理（和非真理）。

在形式验证运动和牛顿物理学之间可以得出另一个相似之处：在牛顿运动定律被接受的早期，许多人渴望相信物理宇宙是确定性的，只要事先对所涉及的质量和动量有足够的了解，所有运动和活动最终都可以被以任意精度计算。遗憾的是，海森堡，玻尔等人的发现带来了量子力学的到来，从而结束了这一信念。他们意识到，在粒子层面上，所有物理行为本质上都是概率性和随机性的，因此是不可预测的。

同样，*形式验证*的目标最终被认为是行不通的。Dijkstra后来放弃探索程序可证明性而转向了研究正确*程序生成*的技术。此技术是为了用方法论使程序员能够以有条理的方式构造程序，确保程序表现出正确的行为。该研究领域与*自顶向下设计*和*功能分解*的技术有很多共同点。

还应该认识到，今天被认为是理所当然的许多编程术语在1968年还没有被牢固地确立。当时对编程概念的术语有很多辩论和讨论。我们今天使用的很多术语花了很多年才被广泛接受。

Dijkstra 名副其实是一名院士，他在著作中倾向于使用技术上冗长的措辞。这在一定程度上可以解释为什么很少有人读过他著名的“GOTO”信。值得注意的是，他鄙视用 bug 一词来表示编程错误，而宁愿用 error 一词。当然，今天这两个术语仍然在编程语境下使用，但 error 是由任何一个人或一台机器产生了错误（因为它总是有）， bug 仅用于人造系统领域，特别是可编程计算机，以表示设计中的特定故障或意外的执行结果。术语 debug 也应运而生，以表示在系统中查找和删除 bug 的特定活动。如果只留下 error 一词， debug 这个好词也不会出现。

# 第一部分



## Dijkstra的信，带评注

接下来是Dijkstra在1968年写给CACM的著名的“GOTO”信，以及从历史角度讨论这封信细节的注释。



编辑：

数年来我观察到，程序员的素质是他们程序中**goto**语句出现密度的递减函数。最近我发现了为什么使用**goto**语句会造成会造成灾难性的后果，并且我深信应该从所有“高级”编程语言（即除纯机器码的所有语言）中废除**goto**语句。当时我并不十分重视这个发现。当时我并不十分重视这个发现。现在，这个主题在最近讨论中的出现敦促了我将我的想法发表。





Dijkstra介绍他已经注意到goto语句在很大程度上不利于它们所在的程序。他认为程序员使用的goto越多，程序员的能力就越差。

他建议应从所有高级编程语言中删除goto语句。他甚至暗示应该从*所有* 编程语言（可能包括机器代码）中删除goto ，人们不禁要问这如何实现。





我的第一句话是，尽管程序员的活动(activity) 在他完成了一个正确程序就结束了， 然而程序员的活动真正的主体部分，其实是这个程序所控制的流程(process)，因为这个流程必须要达到程序员所期望的效果，也必须在动态的表现上满足编程者所期望的规范。不过，一旦程序被编写完成，相关流程的完成就交给机器了。






这一段技术密集的措辞是Dijkstra学术写作风格的典型代表。

这句话仅意味着程序员执行的实际活动不仅是编写程序，还包括控制在代码在机器执行时代码的行为。然而他说，一旦程序员编写了一个工作程序，程序的实际执行就完全只靠机器本身控制。

Dijkstra使用“正确”一词来描述没有 错误 (errors) ，或者按照目前的说法，没有 bug 的程序。“错误”一词反映了当时可以写出能进行“形式化验证”的代码的信念，即代码可以进行一系列的数学和逻辑操作，证明该代码包含错误（逻辑错误，约束错误 (constraint errors)，不变错误 (invariant errors) ...），或代码没有错误即可以*证明是正确的*。正如上面的[背景](#background)部分所述，计算机科学家（或至少程序员）今天并不以这种方式考虑编程。





我的第二句话是，我们的智力很适合掌握静态关系，而我们想象随时间变化的动态流程的能力相对较弱。出于这个原因，我们（既然明智的程序员意识到了我们的局限性）应该尽力缩短静态程序和动态流程之间的概念鸿沟，以尽可能让程序（在文本空间中扩展）和流程（在时间中扩展）之间的对应关联清晰。





Dijkstra在这里观察到，与动态关系相比，人类更擅长想象静态关系。因此他认为，将两种关系表示为程序代码时，我们应将两者之间的差异最小化，以便在源代码本身的结构中明显看出程序的动态（非恒定）方面。

对当前大多数以线性，按语句顺序的方式运行的编程语言来说这说法都是对的。但是，当我们观察到现实世界中的编程任务必须处理的复杂性（例如多任务，多线程，中断处理，易失性硬件寄存器，虚拟内存分页，设备延迟，实时事件处理等等，仅举几例）时，在某种程度上，Dijkstra的行为准则尚未完全实现。简单的一次执行一行的程序执行模型已不足解决当今的编程问题。




现在让我们考虑如何表示一个流程的进度 (progress of a process)。（您可能会以一种非常具体的方式考虑这个问题：假设一个流程（按时间顺序的一串行为(action) ）在某个行为之后停止，我们必须确定哪些数据才能重做流程直到停止的那一点？）假设程序文本纯粹是赋值语句的序列（为方便讨论，赋值语句被视为单个行为的描述），则表示进度只要指向程序文本中两个 *连续的行为的描述* (successive action descriptions) 之间的一点就够了。




Dijkstra开始构建*程序执行*的正式定义，或他所谓*的流程进度*。接下来的讨论类似于在C和C++（和其他）语言所采用的执行模型的正式定义中使用的 *序列点*的定义。

必须记住，我们今天想当然的许多术语在当时还没有牢固地确立，并且没有普遍接受的语言或伪语言用于论述算法和程序。当然，今天的作者会使用诸如C，Java，Pascal，LISP之类的具体语言，或者与这些语言中的一种非常相似的伪语言作为*通用语言*来说明编程概念。





（在没有**goto**语句的情况下，我可以允许自己在上一句的后三个词中出现句法歧义：如果我们将它们解析为“连续的（行为的描述）”，则表示在文本空间中是连续的；如果我们解析为（ “连续的行为”）的描述则是指时间上连续的。）让我们将指向文本中适当位置的指针称为“文本索引”





Dijkstra在典型的学术风格中运用了一些语言上的小聪明，使词组*连续的行为的描述*具有两种不同的含义。这反映了他前面提到的编程任务的双重性质：这些任务与依次执行一个语句（或行为）的顺序性质有关，即程序的源代码由单独的语句（行为）组成序列以反映语句执行的的时间顺序。

他的术语 文本索引 (textual index) 实质上是一个 程序计数器 （Program Counter）。但是，他试图超越简单地跟踪当前线程 (thread) 执行到的位置，而在源代码文本中的语句与程序执行状态之间建立显式连接。因此，更好的术语可能是 语句指针 (statement pointer) 。





当我们纳入 条件语句（**if** *B* **then** *A*），可选择的条件语句（**if** *B* **then** *A*1 **else** *A*2 ），由C. A. R. Hoare引入的 选择语句（**case**[i] **of** (*A*1, *A*2, ···, *An*)）或J. McCarthy（*B*1 → *E*1, *B*2 → *E*2, ···, *Bn* → *En*），事实是，流程进度仍然由*文本索引*表示。





Dijkstra引入了更复杂的流控制语句，例如 **if-then-else**条件语句和**case** （又称为**select**或**switch**）选择语句，并指出这些不会改变其*文本索引* （或*语句指针*）的基本性质。

这反映了这样一个事实，即，当时人们在为编程语言和一般编程理论制定最佳的最小流控制结构集方面付出了很多努力。绝非偶然的是，大多数构造类似于ALGOL支持的控制结构，因为许多从事或影响ALGOL设计的人都是写了大量关于编程的学者。

所有这些工作的主要目标是创建一个命名法(nomeclature)，此命名法不仅可以用于实际编程语言的，而且还可以直接用于编程算法的数学公式化。如上面的[背景](#背景)部分所述，这反映了一种信念，即可以用某种形式表达程序，从而可以用数学方式证明其正确性。





一旦我们的语言里包括了子过程，我们就必须承认单一的文本索引已不再足够描述流程进度。在文本索引指向子过程体内部的情况下，只有当我们还给出是在哪一处调用子过程时才能表示动态流程的进度。包含了子过程，我们可以通过一系列文本索引来表征流程的进度，该序列的长度等于过程调用的动态深度。



这表明，如果程序使用*子过程*（通常称为*过程*，*函数*或*方法*）， 则单个语句指针不足以定义正在执行的程序的状态 。为了处理这种额外的复杂性，Dijkstra定义了 *一系列文本索引*。

现代术语称此为 调用栈 (call stack)，它是程序计数器（也称为 返回地址 ）的数组，每个计数器都指明从哪条语句进行子过程调用。但由于 Dijkstra 正在建立文本索引与程序执行状态之间的关联，因此将调用堆栈视为语句指针数组会更正确。所需的语句指针的数量仅仅是在程序执行中给定的某一时刻起作用的子过程调用数量，即调用栈的深度。





现在让我们考虑 重复语句（例如， **while** *B* **repeat** *A* 或 **repeat** *A* **until** *B*）。从逻辑上讲，这样的语句是多余的，因为我们可以借助递归过程来表示重复。出于现实的原因，我不希望将它们排除在外：一方面，重复语句在当今的设备已经相当方便地实现；另一方面，称为“归纳法”的推理模式使我们有足够的智力掌握重复语句产生的过程。





Dijkstra添加了重复控制流语句。他顺便指出，这样的重复语句完全没有必要，因为可以用等效的递归调用来代替它们。

这反映了一个事实，当时递归非常流行，许多人（尤其是学术界人士）认为递归是表示程序和算法的一种高级形式。流行的原因是，递归定义具有严格的数学历史，特别是 递归公式 (recursive formulas) 和 递推关系 (recurrence relations) 。 递归公式 和 递推关系 处理递归定义的序列，其中序列中的每个元素都用简单的术语和该序列中的先前元素进行定义。两个经典示例是阶乘函数**n! = n(n-1)!**，以及斐波那契数列 **Fi = Fi-2 + Fi-1**。

这是典型的学术观察。从理论上讲，可以将任何循环语句替换为递归调用，并且某些语言（例如LISP）实际上支持递归编程风格（也称为*函数编程*）。但是，对于大多数编程应用程序以及大多数编程语言实际支持的应用程序而言，递归仅扮演次要的角色（但仍然非常有用）。

Dijkstra提到，迭代语句可以在 资源有限的设备 (finite equipment)上实现 ，这当然是所有实际存在的计算机的本质，无论它们拥有多少虚拟内存。这种微妙的方式承认某些形式的递归需要潜在的无限资源（即无限调用堆栈）。考虑一个典型的嵌入式应用程序，它具有一个主程序循环，该循环轮询一个事件，处理该事件，然后等待下一个事件，永远这么循环。这样的无限循环确实可以写成尾递归过程调用，但是那有什么意义呢？使用这种更复杂的为了递归而递归的方式将无法在大多数实际的系统上进行编程。

Dijkstra似乎暗示着迭代循环（归纳）语句在理论上比递归更难掌握，这是只有数学家会说的那种东西。

**迭代**, 动词.请参见*迭代*。





加上重复语句，文本索引已不足以描述流程的进度。然而，在每次进入重复语句时，我们都可以关联一个所谓的“动态索引”(dynamic index)，从而无休止地记录当前进入的重复语句的次序。由于重复语句（就像过程调用一样）可以嵌套应用，因此我们发现，流程的进度现在可以通过文本索引和/或动态索引的（混合）序列来唯一地表示。







通过添加重复控制结构，我们不仅需要一种指明当前语句的方法，而且还需要一种方法跟踪当前正在执行每个循环的哪次迭代 。因此，就像嵌套过程调用一样，我们必须使用  循环迭代堆栈 (loop iteration stack) 来跟踪这些迭代计数，每个（嵌套的）循环有一个这样的堆栈，Dijkstra称之为 动态索引序列 (dynamic index sequence)。

因此，将它们组合到一起，我们有一个 文本索引序列（ 调用堆栈 ）和一个 动态索引序列 （循环迭代堆栈），它们共同定义了正在执行的程序的当前状态。

*（嵌套？）*





要点是这些索引的值都不在程序员的控制范围之内。无论程序员想不想，这些索引的值都是通过程序的编写或流程的动态演变生成的。这些索引提供了独立的坐标来描述流程的进度。









Dijkstra再次指出，显而易见的是，一旦编写并运行了程序，程序员将不再对实际程序执行具有任何控制权。执行由执行过程中任何给定时间点的调用堆栈和循环迭代堆栈的内容表示——Dijkstra称为程序执行的 独立坐标 (independent coordinates)，而我们可以将其简称为程序的 状态 (state)或 执行历史 (execution history)。







为什么我们需要这样的独立坐标？原因是——这似乎是顺序流程所固有的——我们只能根据流程的进度来解释变量的值。如果我们希望计算一个最初是空的房间其中的人数*n*，那么只要看到有人进入房间，我们就可以通过将*n*来增加一来计数。在中间时刻，我们观察到有人进入房间但尚未执行随后的*n*增大，此时*n*的值等于房间中的人数减去一。







Dijkstra指出，只有在给定的时间点之前准确地知道了程序的执行历史，才能知道程序中给定变量的值。换句话说，程序以*确定性的* 方式执行，并且应该有可能通过执行历史（或程序状态的历史），确定任何变量到执行期间的任何时刻的值。

Dijkstra引入了在程序语句完成之前的 中间时刻 (in-between moment) 的概念。这类似于在 C和 C++ 等语言中指定的 序列点 的概念，序列点精确定义了何时发生行为以及以什么顺序发生，同样重要的是，哪些行为没被定义。

程序的执行仅在特定的序列点（通常发生在语句的末尾，函数调用之前）和子表达式求值的特定点上被良好地定义。在任何两个序列点之间，程序的状态都没有明确定义，这意味着，到达下一个序列点之前，程序变量的值处于不确定（或*中间*）状态。

Dijkstra给出了一个简单的例子:计数器的自增，或例如 **n = n + 1** 的语句。当它们实际执行时，在某个时刻会已经读取 **n** 的先前值并将其添加 **1** ，但是尚未将新值写回到变量**n**。这是他所指*的中间*状态，或者是两个*序列点*之间的执行状态，在此期间变量**n**仍包含其旧值而不是其新值。






    **goto** 语句滥用的直接后果是很难找到有意义的 坐标集 (set of coordinates) 来描述流程进度。通常，人们会把一些精心选择的变量的值纳入考虑，但这个方法办不到，因为要知道，根据流程的进度才能理解这些变量的值！当然，使用 **goto** 语句，仍然可以通过计数器来唯一地描述进度，该计数器（即一种标准化的时钟 (normalized clock)）对自程序启动以来 执行的行为个数 (number of actions performed) 进行计数。困难在于，尽管这样的一个坐标是唯一的，但却完全无济于事。因为在这样 *n* 居然等于房间人数减一的坐标系统中，定义所有的流程点变得极度复杂！







终于在这里，我们达到了Dijkstra关于底层的goto陈述的论点的症结。本质上，Dijkstra认为，在程序中对goto语句的“无限制使用”会模糊程序的执行状态和历史记录，因此在任何给定时刻，调用堆栈和循环迭代堆栈的值不再足以确定程序变量的值。

这种混淆是以下事实的结果：不受约束的goto语句可以在控制完成之前将控制权从循环中移出，并且同样可以将控制权转移到已经迭代的循环中间。两种情况都使修改循环迭代堆栈中的计数器的方式变得复杂。

除此之外，还有存在 非局部 (non-local) goto 的可能性， 即将控制权从当前正在执行的子过程转移回先前调用的子过程的goto的可能性，这实际上通过使整个调用堆栈的值无效来破坏执行状态。

Dijkstra陈述了*在中间时刻*将控制从循环或过程中移出的特定示例，这使执行状态从该点开始一直不确定。

另一种说法是，**goto**可以使应该由程序结构保证违背的*程序不变性*无效 。他在此处使用的示例不变式是，计数器**n**始终表示房间中的人数。允许非结构化的goto更改执行过程可能导致不变量变为无效（即可变），从而使**n**的值变得毫无意义，或者至少使从执行历史中确定其真实值极为困难。







现在的 **go to** 语句太原始了；太多地把程序弄得一团糟。如果控制goto的使用，它还是可以被考虑使用并被欣赏的。我并不是说我详尽无遗的提及了可满足所有需要的语句，但是无论提出什么语句（例如 终止语句 (abortion clauses)），它们都用有帮助的且易于管理的方式，满足了维护一个描述流程的，与程序员无关的坐标系 (a programmer independent coordinate system) 的要求。







Dijkstra说goto语句*所代表的意思*其实是*非结构化* goto，也就是，在其他结构化语言中没有任何限制的使用的goto语句。

把 goto 语句的使用限制在一些简单的、结构良好的控制，例如从循环中提前退出，错误处理 (error handling)（又称异常 (exceptions)）等等可以将 goto 语句带回到 结构化的控制流修正领域 (structured control flow modification)。但是，如果某种语言没有强制实施这些限制的规则，就不能说这语言提供的 goto 语句结构合理。

Dijkstra承认并非某种语言提供的所有流控制结构都可以满足所有编程需求。这意味着对于那些需要更复杂的流控制的罕见编程情况，goto仍然占有一席之地。

Dijkstra提到了*终止子句*或现在通常称为 *异常处理程序*的内容，暗示这些东西实际上是可以通过定义使其在结构化语言的范围内表现良好的花哨**goto**，即这些**goto**不会以偶然的方式破坏执行状态。

像Ada，C ++，Java和其他面向对象语言的异常处理子句在大多数情况下都遵循该原则，因此当这些语言引发异常时，执行状态（包括全局变量和局部变量，过程调用堆栈，堆等）以干净且可预测的方式更改。

更多原始语言（例如FORTRAN，COBOL，C，Pascal等）可以提供某些原始异常处理机制，但是使用它们不能保证干净地保留执行状态或正确释放分配的资源。







用公正的承认来结束这篇文章是很难的。我要判断我的思想受到谁影响吗？显然我受到 Peter Landin 和 Christopher Strachey 的影响。最后，我想记录一下（我记得很清楚）海因茨·泽马内克（Heinz Zemanek）在1959年初在哥本哈根举行的ALGOL前会议上如何明确表达了他的疑问，即对**goto**语句是否应与赋值语句一视同仁。在一定程度上，我责怪自己没有描绘出他讲话的后果。





Dijkstra在此说明在影响了他的人。如[背景](#背景)，ALGOL语言设计的许多人也参与了有关正确的语言设计和正确的程序控制流程结构的讨论。





**goto**语句不合需要的说法并非新鲜事物。我记得已经阅读了明确的建议，建议上明确推荐只将 **goto** 用在警报时的退出  (alarm exit)，但是我无法查到在哪。据推测，它是由C. A. R. Hoare制造的。在[[1，Sec.[3.2.1]](http://david.tribble.com/text/goto.html#WIRTH66)沃思和霍尔（Warth）共同朝着推动**选择语句**的方向发表了看法：

> “与条件语句类似，它比**转到**语句和开关更清晰地反映了程序的动态结构，并且消除了在程序中引入大量标签的需要。”









Dijkstra指出，可以将goto语句视为（仅）*警报退出*可接受的方法，我们将其称为*致命异常*。对于缺少健壮的异常处理机制的语言，gotos可能是唯一的实用替代品。

Dijkstra提到了Hoare和Wirth提出的**case**（或**select**）控制流结构的设计。今天，我们认为这种控制结构是理所当然的，但是当时它的优点仍在争论中。Dijkstra提醒我们，它最初是作为笨拙地使用**if**，**goto**和**label**的笨拙替代方案的。





在[ [2](http://david.tribble.com/text/goto.html#BOHM66) ]中，Guiseppe Jacopini似乎证明了**goto**语句的（逻辑）多余。但是，不建议您尝试将某种流程图机械地转换为无跳跃的流程图。不要期望这样得到的流程图比原始流程图更透明。





Dijkstra 提到了流程图 (flow diagrams)，它反映了当时程序设计的最新水平。从那时起，编程技术经历了结构化编程 (structured programming)，自顶向下编程 (top-down programming)，面向对象编程 (object-oriented programming)，组件编程 (component programming)，切面编程 (aspect programming) 等阶段的发展。然而，尽管在设计上的这些进步，但 Dijkstra 关于非结构化程序流的主要观点历久弥新。

必须指出的是，Dijkstra对这个问题的最终评论似乎暗示着，从一个人自己的程序中完全删除所有 goto 是一个坏主意。虽然他说，已证明对任何给定的程序goto语句其实都是多余的，Dijkstra 仍然承认，消消除*所有*在程序中的 goto 会使程序的控制流更加难以理解。

他实际上是在论证程序中的某些 goto 可能有用，并且实际上可能会使程序更易于理解。因此，可以肯定地说Dijkstra认为goto语句是*有害的*，但不是*致命的*，并且肯定不是*无用的*。





参考文献：

1.  Wirth，Niklaus和Hoare C. A. R.

   对ALGOL的发展做出了贡献。

   通讯 ACM 9

   （1966年6月），第413-432页。

   

2.  伯姆，Corrado和Jacopini Guiseppe。

   流程图，图灵机和语言只有两个编排规则。

   通讯 ACM 9

   （1966年5月），366-371。

   

荷兰埃因霍温* Edsger W. Dijkstra
*技术大学*






# 第二部分 


## 结构化程序设计


自从 Dijkstra 的那封信发表以来，程序语言是否已经发展到了 <b>goto</b> 语句不在被需要的地步？

20世纪60年代以来，编程语言的理论已经出现了几次进步。



每一个方法都导致了编程语言理论的范式转变、影响了程序员日常编写程序的方式并改变了编程语言的设计方式及其提供的功能。但是所有这些进步都在比简单的执行语句更高的级别（即在 子过程 (procedure)，数据对象 (data objects)，程序模块 (program modules) 等的结构）影响了程序的结构。在最底层的 顺序语句的级别 ( sequential statement level)进行编程的基本方法与最初的编程语言（如FORTRAN和COBOL）。


以下各节描述了当今大多数编程语言中普遍可用的程序流结构。自从结构化编程问世以来，它们几乎保持不变。（这些构造以伪代码而不是任何特定语言显示。）


## 其他方法

# 第三部分

## Goto 还有使用必要性吗？
良好的编程语言设计对一种语言提供足够完整且功能强大的流控制结构集，使得用这门语言为任何编程任务编写高效的代码相对容易。一种语言不应过分雄心勃勃，提供太多不同的方式来完成相同的事情，而与此同时，它也不应提供过少的表达的方式而表达能力不足。提供的流控制语句集应该足够强大和灵活，以便程序员可以清晰，简洁地表达自己的思想，而不必只是为了避开语言的语法限制而求助于使用无关的控制变量或不自然地重新布置他的代码。

# 总结
## Goto 之道	

显然，循环逃逸机制和异常处理语句使代码更具可读性也更高效。当然，这种流控制机制实际上只是变相的 goto 语句，是在底层使用机器码 jump 指令实现的。 但它们不会破坏或混淆程序的执行状态。因此，根据 Dijkstra 的“可以确定地跟踪程序执行”的行为准则来判断的话，高级语言可以接受它们这些控制流机制。

例 <a href="#example-t-2">T-2</a> 和例 <a href="#example-n-1">N-1</a> 证明，<i>只要</i>编程语言提供一组合理的控制结构来代替简单的 goto 语句，就可以满足 Dijkstra 的箴言。


  例 <a href="#example-e-1">E-1</a> 和例 <a href="#example-n-2">N-2</a>
        证明，如果一种编程语言没有提供合理且强大的流控制结构，那么<i>只有</i>依靠使用 goto 语句才能合理地解决某些编程问题。



        一些结构化的编程语言根本不提供goto语句。诸如 Smalltalk，Eiffel 和 Java 之类的语言为早期和嵌套循环退出以及异常处理提供了控制语句，因此实际上并不需要 goto。一些其他语言（例如Modula-2和Oberon）也未提供 goto 语句 ，但似乎也缺少足够的流控制结构，因此无法方便地编写提前退出循环和异常处理的代码。看上去这些语言是失败的语言实验，因为它们呆板地遵循了 Dijkstra 的箴言。



        Dijkstra 认为非结构化的 goto 语句不利于良好的编程的信念仍然是正确的。正确设计的语言应提供足够强大的流控制结构，以应对几乎所有编程问题。同样，当必须使用流控制语句不够灵活的语言时，程序员应在使用非结构化替代方案时保持克制。这就是 goto 之道：知道何时将其善用，知道何时不将其恶用。
